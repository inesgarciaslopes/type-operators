% !TeX root = main.tex

\newcommand{\srule}[1]{\textsc{#1}}
% Glorious technicolour
\newcommand{\typec}[1]{{\color{RoyalBlue}{#1}}} % c for colour
\newcommand{\termc}[1]{{\color{RedViolet}{#1}}}
%CornflowerBlue, SpringGreen, Melon???
\newcommand{\kindc}[1]{{\color{RedOrange}{#1}}} % kind
\newcommand{\tsymc}[1]{{\color{OliveGreen}{#1}}} % terminal symbol
\newcommand{\nsymc}[1]{{\color{BrickRed}{#1}}} % nonterminal symbol
% \newcommand{\parc}[1]{{\color{ForestGreen}{#1}}} % parameter
\newcommand{\blk}[1]{{\color{black}{#1}}}

% Coloured metavariables
\newcommand{\TT}{\typec{T}}
\newcommand{\UT}{\typec{U}}
\newcommand{\VT}{\typec{V}}
\newcommand{\WT}{\typec{W}}
\newcommand{\XT}{\typec X}
\newcommand{\YT}{\typec Y}
\newcommand{\Xnt}{\nsymc X}
\newcommand{\Ynt}{\nsymc Y}
\newcommand{\Znt}{\nsymc Z}
\newcommand{\Ent}{\nsymc E}
\newcommand{\Fnt}{\nsymc F}
\newcommand{\Rnt}{\nsymc R}
\newcommand{\Ant}{\nsymc A}
\newcommand{\Bnt}{\nsymc B}
\newcommand{\ntdelta}{\nsymc\delta}
\newcommand{\ntgamma}{\nsymc\gamma}
\newcommand{\PP}{\termc{p}}
\newcommand{\tiota}{\typec \iota}
\newcommand{\talpha}{\typec \alpha}
\newcommand{\tbeta}{\typec \beta}

% When a proof ends with a list environment, place \qedhere as the
% last thing before \end{enumerate} or \end{itemize}.

% Each case in a proof (inductive, coinductive, ...)
\newcommand{\Case}{\par\vspace{.1ex}\indent\textit{Case}\xspace}
\newcommand{\Cases}{\par\vspace{.1ex}\indent\textit{Cases}\xspace}
\newcommand{\Subcase}{\par\vspace{.1ex}\indent\textit{Subcase}\xspace}

% Grammar definition
\newcommand{\grmeq}{\; ::= \;}
\newcommand{\grmor}{\; \mid \;}

% Keywords and Identifiers
\newcommand{\keyword}[1]{\ensuremath{\mathsf{#1}}\xspace}
\newcommand{\tkeyword}[1]{\keyword{\typec{#1}}}
\newcommand{\tekeyword}[1]{\keyword{\termc{#1}}}
\newcommand{\pkeyword}[1]{\keyword{\termc{#1}}}
\newcommand{\symkeyword}[1]{\keyword{\tsymc{#1}}}
\newcommand{\pakeyword}[1]{\keyword{\typec{#1}}}
\newcommand{\identifier}[1]{\ensuremath{\mathrm{#1}}\xspace}
\newcommand{\Label}[1]{\tkeyword{#1}}
\newcommand{\Proc}[1]{\identifier{\termc{#1}}}	% another name for identifier

% Some frequent labels
\newcommand{\notl}{\Label{Not}}
\newcommand{\andl}{\Label{And}}
\newcommand{\quitl}{\Label{Quit}}
\newcommand{\gol}{\Label{Go}}
\newcommand{\quits}{\symkeyword{Quit}}
\newcommand{\gos}{\symkeyword{Go}}
\newcommand{\nill}{\Label{Nil}}
\newcommand{\consl}{\Label{Cons}}
\newcommand{\nodel}{\Label{Node}}
\newcommand{\donel}{\Label{Done}}
\newcommand{\morel}{\Label{More}}
\newcommand{\dones}{\symkeyword{Done}}
\newcommand{\mores}{\symkeyword{More}}
\newcommand{\leafl}{\Label{Leaf}}
\newcommand{\leftl}{\Label{Left}}
\newcommand{\rightl}{\Label{Right}}
\newcommand{\fstl}{\Label{Fst}}
\newcommand{\sndl}{\Label{Snd}}
% Some frequent type names
% Some frequent type names
\newcommand{\intlistt}{\tkeyword{IntList}}
\newcommand{\finstreamt}{\tkeyword{FinStream}}
\newcommand{\intstreamt}{\tkeyword{IntStream}}
\newcommand{\streamt}{\tkeyword{Stream}}
\newcommand{\listt}{\tkeyword{List}}
\newcommand{\inttreet}{\tkeyword{IntTree}}
\newcommand{\inttreert}{\tkeyword{IntTreeR}}
\newcommand{\intreet}{\tkeyword{InputTree}}
\newcommand{\htreet}{\tkeyword{HTree}}
% some frequent processes
\newcommand{\procname}[1]{\mathtt{#1}}
\newcommand{\sendint}{\procname{sendInt}}

% labels in the LTS and terminal symbols in grammars
\newcommand{\unitl}{\symkeyword{unit}}
\newcommand{\ldomain}{\tsymc{\shortrightarrow_d}}
\newcommand{\lrange}{\tsymc{\shortrightarrow_r}}

% Qualifiers
\newcommand{\un}{\tkeyword{un}}
\newcommand{\lin}{\tkeyword{lin}}

% Operators and Symbols
%\renewcommand{\operatorname}[1]{\mathsf{#1}} % mathsf is for keywords;
%we need to clearly distinguish operators from keywords in sequents
%\renewcommand{\operatorname}[1]{\mathit{#1}}
\newcommand{\operator}[1]{\operatorname{#1}}
\newcommand{\fv}{\operator{fv}}      % Free Vars. Deprecated: use
\newcommand{\ids}{\operator{ids}}
% process formation
\newcommand{\dom}{\operator{dom}} % Deprecated: use \notindom
\newcommand{\treeof}{\operator{treeof}}
\newcommand{\typeof}{\operator{typeof}}
\newcommand{\tree}{\treeof}
\newcommand{\Path}{\operator{path}}
\newcommand{\subexpr}{\operator{subterms}}
\newcommand{\compat}{\bowtie}
\newcommand{\Eq}{\doteq} % The equal symbol in equations
\newcommand{\Empty}{\varepsilon} % The empty sequence
\newcommand{\emptyword}{\nsymc\Empty}
\newcommand{\sub}{<:}	% subtyping
\newcommand{\super}{:>}
\newcommand{\teq}{\simeq} % type equivalence
\newcommand{\gequiv}{\approx} % grammar bisimulation
\newcommand{\Oplus}{\hspace{-.1ex}\oplus\hspace{-.1ex}} % internal choice with a better spacing
\newcommand{\pair}[2]{\langle{#1},{#2}\rangle}
\newcommand{\eval}[2]{{#1}\Downarrow{#2}}
\newcommand{\erase}{\operator{erase}}
\newcommand{\incr}[1]{{#1}^{+1}}
% naturals
\newcommand{\zero}{\pakeyword z}
\newcommand{\zerol}{\keyword{z}}
\newcommand{\zerop}{\pkeyword{z}}
\newcommand{\succc}{\pakeyword s} % the constructor
\newcommand{\succl}{\keyword{s}}
\newcommand{\succp}{\pkeyword{s}}
\renewcommand{\succ}[1]{\succc\,#1}
%\
\newcommand{\dl}{\keyword d}
\newcommand{\cl}{\keyword c}

% The subscripts for the various shades
\newcommand{\sysvariant}[1]{\mathsf{#1}}
\newcommand{\sysinfty}{\sysvariant \infty}
\newcommand{\sysf}{\sysvariant f}
\newcommand{\sysr}{\sysvariant r}
\newcommand{\sysone}{\sysvariant 1}
\newcommand{\sysp}{\sysvariant p}
\newcommand{\systwo}{\sysvariant 2}
\newcommand{\syscf}{\sysvariant c}
\newcommand{\sysn}{\sysvariant n}

% Sets of types, contexts, processes
\newcommand{\setname}[1]{\mathbb{#1}}
\newcommand{\types}{\setname{T}} % a class of types
\newcommand{\typesi}{\setname{T}_\sysinfty}
\newcommand{\typesf}{\setname{T}_\sysf}
\newcommand{\typesr}{\setname{T}_\sysr}
\newcommand{\typeso}{\setname{T}_\sysone}
\newcommand{\typesp}{\setname{T}_\sysp}
\newcommand{\typest}{\setname{T}_\systwo}
\newcommand{\typescf}{\setname{T}_\syscf}
\newcommand{\typesn}{\setname{T}_\sysn}
\newcommand{\procs}{\setname{P}}
\newcommand{\ctxs}{\setname{C}}
\newcommand{\vals}{\setname{V}}
\newcommand{\vars}{\setname{X}}
\newcommand{\labels}{\setname{L}}
\newcommand{\pow}{\mathcal{P}}
\newcommand{\powtree}{\pow(\treetypes\times\treetypes)}
\newcommand{\powsyn}{\pow(\syntypes\times\syntypes)}
\newcommand{\powjudge}{\pow(\ctxt\times\proc)}

% The identity relation
\newcommand{\id}{\mathsf{id}}

% Functions for coinductive relations
\newcommand{\nbb}{\mathbb{N}}
\newcommand{\D}{\mathcal{D}}
\newcommand{\Ds}{\mathcal{D}_s}
\newcommand{\E}{\mathcal{E}}
\newcommand{\Es}{\mathcal{E}_s}
\newcommand{\lcal}{\mathcal{L}}
% \newcommand{\lcal}{\operator{traces}}
\newcommand{\J}{\mathcal{J}}
\newcommand{\Js}{\mathcal{J}_s}
\newcommand{\N}{\mathcal{N}}
\newcommand{\ocal}{\mathcal{O}}
\newcommand{\pcal}{\mathcal{P}}
\newcommand{\R}{\mathcal{R}}
\renewcommand{\S}{\mathcal{S}}
\newcommand{\Ss}{\mathcal{S}_s}
\newcommand{\T}{\mathcal{T}}
% \newcommand{\U}{\mathcal{U}}
\newcommand{\V}{\mathcal V}
\newcommand{\X}{\mathcal X} % program var set
\newcommand{\xcal}{\mathcal{X}} % program var set
\newcommand{\typeidset}{\mathcal Z}
\newcommand{\procidset}{\X}
% \newcommand{\procidset}{\mathcal A}
\newcommand{\eqctx}{\Theta} % Equational contexts (pairs of types)
\newcommand{\cls}{\Phi} % Closures, id-context map

% Operations
\newcommand{\absorbing}[1]{\blk{\operatorname{absorbing}_{S}(#1)}}
\newcommand{\absorbings}[2]{\blk{\operatorname{absorbing}_{#1}(#2)}}
\newcommand{\reachable}[1]{\blk{\operatorname{reachable}_{S}(#1)}}
\newcommand{\reachables}[2]{\blk{\operatorname{reachable}_{#1}(#2)}}
\newcommand{\arity}{\operatorname{arity}}
\newcommand{\unfold}{\operatorname{unfold}}
\newcommand{\rename}{\operatorname{rename}}
\newcommand{\renames}{\operatorname{rename}_{S}}
\newcommand{\renamec}[1]{\operatorname{rename}_{#1}}
\newcommand{\first}{\operatorname{first}}
\newcommand{\firsts}{\operatorname{first}_{S}}
\newcommand{\renameb}[1]{\blk{\renames(}#1\blk{)}}
\newcommand{\renamed}[2]{\blk{\renamec{#1}(}#2\blk{)}}
\newcommand{\firstb}[1]{\blk{\firsts(}#1\blk{)}}
\newcommand{\firstbu}[1]{\blk{\first_{S\cup\fv (\tabs{\talpha}{\kind}{T})}(}#1\blk{)}}
\newcommand{\word}{\operatorname{word}}
\newcommand{\wordb}[1]{\blk{\word(}#1\blk{)}}
\newcommand{\tstate}{\operatorname{state}}
\newcommand{\tstateb}[1]{\blk{\tstate(}#1\blk{)}}
\newcommand{\subject}{\operatorname{subj}}
\newcommand{\subj}[1]{\subject(\termc{#1})}
\newcommand{\agree}[4]{\operatorname{agree}^{\termc{#1 #2}}(\termc{#3},\termc{#4})}
\newcommand{\remove}{\!\setminus\!}
\newcommand{\domof}[1]{\dom(#1)}
\newcommand{\indom}[2]{{#1}\in\domof{#2}}
\newcommand{\notindom}[2]{{#1}\notin\domof{#2}}
\newcommand{\notinfv}[2]{{#1}\notin\mathit{fv}({#2})}
%\newcommand{\freshrename}[2]{\widehat{#1}(#2)}
\newcommand{\freshrename}[2]{{#1}(#2)}
\newcommand{\dual}{\overline}
\newcommand{\shuffle}{\operatorname{shuffle}}
\newcommand{\concat}[2]{\typec{#1}\,\blk\fatsemi\,\typec{#2}}
\newcommand{\swap}{\mathtt{swap}}

% forall l in L -- to be used in rules for records (branch, select,
% branchp)
\newcommand{\foralllabel}[2]{(\forall{#1}\in{#2})}
\newcommand{\foralllinL}{\foralllabel \ell L}

% Tags for examples
\newcommand{\tick}{{\color{green}\checkmark}}
\newcommand{\cross}{{\color{red}$\times$}}

% Introducing a new relation in a figure
\newcommand{\declrel}[2]{#1\hfill\fbox{{#2}}}

\newcommand{\inductive}{(\emph{inductive})\xspace}
\newcommand{\coinductive}{(\emph{coinductive})\xspace}

%%% KINDS

\newcommand{\kind}{\kindc{\kappa}}
\newcommand{\kindp}{\kindc{\kappa'}}
\newcommand{\skind}{\kindc{\textsc s}}
\newcommand{\tkind}{\kindc{\textsc t}}
\newcommand{\vkindp}{\vkind'}
\newcommand{\karrow}[2]{\kindc{{#1}\Rightarrow{#2}}}
\newcommand{\kast}{\kindc *}
\newcommand{\kindi}{\kindc{\iota}}


%%% TYPES
\newcommand{\tappdual}[1]{\tapp{\Dual}{#1}}
\newcommand{\duall}{\keyword{\tsymc{Dual}}}
\newcommand{\waitl}{\keyword{\tsymc{Wait}}}
\newcommand{\closel}{\keyword{\tsymc{Close}}}
\newcommand{\Sharpp}{\keyword{\tsymc{\sharp}}}




% Prefixes
\newcommand{\spref}{\typec{\textsc s}}
\newcommand{\tpref}{\typec{\textsc t}}

% Type constructors
\newcommand{\End}{\tkeyword{End}}
\newcommand{\Close}{\tkeyword{Close}}
\newcommand{\Wait}{\tkeyword{Wait}}
\newcommand{\Skip}{\tkeyword{Skip}}
\newcommand{\Int}{\tkeyword{Int}}
\newcommand{\Char}{\tkeyword{Char}}
\newcommand{\Bool}{\tkeyword{Bool}}
\newcommand{\Unit}{\tkeyword{Unit}}
\newcommand{\String}{\tkeyword{string}}
\newcommand{\Dual}{\tkeyword{Dual}}
\newcommand{\Sharp}{\typec\sharp}
\newcommand{\Semi}{\typec;}
\newcommand{\Arrow}{\typec\rightarrow}
\newcommand{\Iotaz}{\typec{\iota_0}}

\newcommand{\INp}{?}
\newcommand{\INn}[1]{\typec{\INp{#1}}}		% no trailing dot
\newcommand{\OUTp}{!}
\newcommand{\OUTn}[1]{\typec{\OUTp{#1}}}	% no trailing dot
\newcommand{\MSGp}{\sharp}
\newcommand{\MSGn}[1]{\typec{\MSGp{#1}}}	% no trailing dot
\newcommand{\IN}[2]{\typec{\INn{#1}.{#2}}}
\newcommand{\OUT}[2]{\typec{\OUTn{#1}.{#2}}}
\newcommand{\MSG}[2]{\typec{\MSGn{#1}.{#2}}}
% \newcommand{\reck}{\tkeyword{rec}}
\newcommand{\REC}[2]{\typec{\reck\,{#1}.{#2}}}
\newcommand{\variantf}[3]{\langle{#1}\colon {#2}\rangle_{{#1}\in{#3}}} % Full
\newcommand{\variant}[3]{\variantf{#1}{#2_#1}{#3}}
\newcommand{\variants}[1]{\langle{#1}\rangle}
\newcommand{\rchannel}[4]{\{{#1}\colon {#2}, {#3}\colon {#4}\}}
\newcommand{\recordf}[3]{\{{#1}\colon {#2}\}_{{#1}\in{#3}}} % Full
\newcommand{\records}[1]{\{#1\}}
\newcommand{\record}[3]{\recordf{#1}{{#2}_{#1}}{#3}} % Records indexed by sets L of labels, used for internal/external choice types and case processes
\newcommand{\varrecf}[3]{\llparenthesis{#1}\colon {#2}\rrparenthesis_{{#1}\in{#3}}}
\newcommand{\varrecs}[1]{\llparenthesis{#1}\rrparenthesis}
\newcommand{\varrec}[3]{\varrecf{#1}{{#2}_{#1}}{#3}}
\newcommand{\intchoicep}{\Oplus}
\newcommand{\intchoice}{\typec\intchoicep} % internal choice
\newcommand{\extchoicep}{\&}
\newcommand{\extchoice}{\typec\extchoicep}	% external choice
\newcommand{\choicep}{\odot}
\newcommand{\choice}{\typec\choicep}
\newcommand{\textchoide}[1]{\typec{\extchoice\{#1\}}}
\newcommand{\tintchoide}[1]{\typec{\intchoice\{#1\}}}

\newcommand{\tchoice}[1]{\typec{\choicep\{#1\}}}
% \newcommand{\choice}{\typec\star}
\newcommand{\semit}[2]{\typec{{#1};{#2}}}
\newcommand{\dott}[2]{\typec{{#1}.{#2}}} %dot version of semi
\newcommand{\function}[2]{\typec{#1 \rightarrow #2}}
\newcommand{\seqcomp}[2]{\typec{#1}\Semi\ \typec{#2}}
\newcommand{\afunction}[2]{\typec{#1}\rightarrow\typec{#2}}
\newcommand{\afunctionstar}[2]{\typec{#1}\rightarrow^{*}\typec{#2}}
\newcommand{\pairt}[2]{\typec{#1 \otimes #2}}
% \newcommand{\varrec}[2]{\typec{{#1}\diamond{#2}}}
\newcommand{\fop}[2]{\typec{{#1}\diamond{#2}}} % functional operator
\newcommand{\tapp}[2]{\typec{{#1}\,{#2}}}
\newcommand{\tabs}[3]{\typec{\lambda\tbind{#1}{#2}.{#3}}}

\newcommand{\abs}[2]{\lambda\tbind{#1}{#2}}
%\tabs e \tlambda are duplicated.
\newcommand{\tlambda}[3]{\typec{\lambda\tbind{#1}{#2}.{#3}}}
\newcommand{\tforall}[1]{\typec{\forall}_\kindc{#1}}
\newcommand{\texists}[1]{\typec{\exists}_\kindc{#1}}
\newcommand{\tquantinfix}[3]{\quant\,\tbind{#1}{#2}\typec{.\,#3}}
\newcommand{\tmuinfix}[3]{\typec{\mu}\,\tbind{#1}{#2}\typec{.\,#3}}
\newcommand{\tmu}[1]{\typec{\mu}_\kindc{#1}}
\newcommand{\tbind}[2]{\typec{#1}\blk{\colon}\kindc{#2}} % binding for a type
\newcommand{\semitapp}[2]{\typec{;\ {#1}\ {#2}}}
\newcommand{\quant}[1]{\typec{\exists\!\forall}_\kindc{#1}}
\newcommand{\lquant}[1]{{\exists\!\forall}_\kindc{#1}}
\newcommand{\polyt}[2]{\quantf_{\kindc{#1}}{#2}}
\newcommand{\foralltinfix}[3]{\typec{\forall\tbind{#1}{#2}.\,#3}}
\newcommand{\existstinfix}[3]{\typec{\exists\tbind{#1}{#2}.\,#3}}
\newcommand{\forallt}[2]{\typec{\forall_{\kindc{#1}}{#2}}}
\newcommand{\existst}[2]{\exists_{\kindc{#1}}{#2}}
\newcommand{\trecord}[2]{\typec{\{\overline{{#1}\colon{#2}}\}}}
\newcommand{\tvariant}[2]{\typec{\langle\overline{{#1}\colon{#2}}\rangle}}
\newcommand{\tbananas}[2]{\typec{\llparenthesis\overline{{#1}\colon{#2}}\rrparenthesis}}
%\newcommand{\tchoice}[2]{\typec\odot\trecord{#1}{#2}}
\newcommand{\tbanana}[1]{\typec{\llparenthesis\overline{#1}\rrparenthesis}}
% \newcommand{\tchoice}[2]{\spref\tbananas{#1}{#2}}
\newcommand{\texttchoice}[2]{\typec\&\trecord{#1}{#2}}
\newcommand{\tinttchoice}[2]{\typec\oplus\trecord{#1}{#2}}
\newcommand{\textchoice}[1]{\typec{\&_{\{\overline{#1}\}}}}
\newcommand{\tintchoice}[1]{\typec{\oplus_{\{\overline{#1}\}}}}
\newcommand{\tdual}[1]{\tapp\Dual{#1}}

% Predefined types (to use in grammars, examples, etc)
\newcommand{\inty}{\IN TS} % \int is taken
\newcommand{\outt}{\OUT TS}
\newcommand{\msgt}{\MSG TS}
\newcommand{\recordt}[3]{\typec{\recordf{#1}{#2}{#3}}}
\newcommand{\recordv}[3]{\typec{\{{#1}\colon {#2}\}^{{#3}}}}
\newcommand{\vairantt}[3]{\typec{\variant{#1}{#2}{#3}}}
\newcommand{\extct}{\extchoice\recordt \ell T L}
\newcommand{\intct}{\intchoice\recordt \ell T L}
%\newcommand{\choicet}{\choice\recordt \ell T L}
\newcommand{\choicet}{\typec{T \choice U}}
\newcommand{\callt}[2]{\typec{{#1}\langle{#2}\rangle}}

% % Lists of IN/OUT types
% \newcommand{\INSn}[2]{?^{#1}{#2}}		% no trailing dot
% \newcommand{\OUTSn}[2]{!^{#1}{#2}}		% no trailing dot
% \newcommand{\INS}[2]{\INSn{#1}{#2}.}
% \newcommand{\OUTS}[2]{\OUTSn{#1}{#2}.}

%%% TERMS (aka EXPRESSIONS)

% Term keywords
\newcommand{\letk}{\tekeyword{let}}
\newcommand{\ink}{\tekeyword{in}}
\newcommand{\matchk}{\tekeyword{match}}
\newcommand{\withk}{\tekeyword{with}}
\newcommand{\casek}{\tekeyword{case}}
\newcommand{\ofk}{\tekeyword{of}}
\newcommand{\ask}{\tekeyword{as}}
\newcommand{\sendk}{\tekeyword{send}}
\newcommand{\receivek}{\tekeyword{receive}}
\newcommand{\forkk}{\tekeyword{fork}}
\newcommand{\newk}{\tekeyword{new}}
\newcommand{\fixk}{\tekeyword{fix}}
\newcommand{\closek}{\tekeyword{close}}
\newcommand{\reck}{\tekeyword{rec}}
\newcommand{\selectk}{\tekeyword{select}}
\newcommand{\selectc}[2]{\selectk\,\termc{#1}\,\ask\,\typec{#2}}

% Terms (aka Expressions)
\newcommand{\ebind}[2]{\termc{#1}\colon\typec{#2}}
\newcommand{\eubind}[2]{\termc{#1}\colon^{\!\!\!\omega}\:\typec{#2}} % unrestricted
\newcommand{\eunit}{\termc{\{\}}}
% \newcommand{\eunit}{\termc{()}}
\newcommand{\eapp}[2]{\termc{#1}\,\termc{#2}}
\newcommand{\erec}[3]{\termc{\reck\,\ebind{#1}{#2}.{#3}}}
\newcommand{\eabs}[3]{\termc{\lambda\ebind{#1}{#2}.{#3}}}
\newcommand{\etabs}[3]{\termc{\Lambda\tbind{#1}{#2}.{#3}}} % term-level type abs
\newcommand{\etapp}[2]{\termc{{#1}[\typec{#2}]}}
\newcommand{\erecord}[2]{\termc{\{\overline{{#1}={#2}}\}}} % TErm record
\newcommand{\elet}[4]{\termc{\letk\,\{\overline{{#1}={#2}}\}={#3}\,\ink\,{#4}}}
\newcommand{\ematch}[2]{\termc{\matchk\,{#1}\,\withk\,{#2}}}
\newcommand{\eunitlet}[2]{\termc{\letk\,()={#1}\,\ink\,{#2}}}
\newcommand{\evariant}[3]{\termc{\langle{#1}={#2}\rangle\,\ask\,\typec{#3}}}
\newcommand{\ecase}[2]{\termc{\casek\,{#1}\,\ofk\,{#2}}}
\newcommand{\epair}[2]{\termc{\{{#1},{#2}\}}}

% Labels in automata are not types
\newcommand{\Endl}{\keyword{End_\sharp}}
\newcommand{\Waitl}{\keyword{Wait}}
\newcommand{\Closel}{\keyword{Close}}
\newcommand{\Duall}{\keyword{Dual}}
\newcommand{\errorl}{\keyword{error}}
\newcommand{\badl}{\keyword{bad}}

% SYSTEM F
\newcommand{\FM}[1]{F^{#1}}
\newcommand{\FMOmega}[1]{F^{#1}_\omega}
\newcommand{\FMu}{\FM{\mu}}
\newcommand{\FMuDot}{\FM{\mu\cdot}}
\newcommand{\FMuSemi}{\FM{\mu;}}
\newcommand{\FMuOmega}{\FMOmega{\mu}}
\newcommand{\FMuDotOmega}{\FMOmega{\mu\cdot}}
\newcommand{\FMuSemiOmega}{\FMOmega{\mu;}}
\newcommand{\FMuAstOmega}{\FMOmega{\mu_\ast}}
\newcommand{\FMuAstDotOmega}{\FMOmega{\mu_\ast\cdot}}
\newcommand{\FMuAstSemiOmega}{\FMOmega{\mu_\ast;}}

% CONTEXTS
\newcommand{\emptyCtx}{\cdot}

%%% PROCESSES

% Process constructors
\newcommand{\PAR}{\mid}
\newcommand{\NU}[3]{\termc{(\nu{#1}{#2}){#3}}}
% \newcommand{\thread}[1]{\termc{\bullet{#1}}}
\newcommand{\thread}[1]{\termc{\langle{#1}\rangle}}

% \newcommand{\INACT}{\mathbf{\termc{0}}}
% \newcommand{\RES}[4]{(\nu{#1}\colon{#2},{#3}\colon{#4})}	% annotated version
% \newcommand{\IF}[2]{\ifk\ #1\ \thenk\ #2\ \elsek\ }
% \newcommand{\IFTHEN}[2]{\ifk\ #1\ \thenk\ #2}
% \newcommand{\THEN}{\thenk\ }
% \newcommand{\ELSE}{\elsek\ }
% \newcommand{\RECEIVEn}[2]{{#1}?{#2}}	% no dot version
% \newcommand{\SENDn}[2]{{#1}!{#2}}	% no dot version
% \newcommand{\RECEIVE}[2]{\RECEIVEn{#1}{#2}.}
% \newcommand{\SEND}[2]{\SENDn{#1}{#2}.}
% \newcommand{\SELECTn}[2]{\termc{{#1}\lhd{#2}}}	% no dot version
% \newcommand{\SELECT}[2]{\SELECTn{#1}{#2}.}
% \newcommand{\BRANCH}[4]{{#1}\rhd\record{#2}{#3}{#4}}
% \newcommand{\BRANCHS}[2]{{#1}\rhd\{{#2}\}}
% \newcommand{\BRANCHONE}[3]{\BRANCHS{#1}{{#2}\colon{#3}}}
% \newcommand{\BRANCHn}[2]{{#1}\rhd{#2}}
% \newcommand{\CALL}[2]{{#1}\langle{#2}\rangle}
% \newcommand{\CALLT}[2]{\typec{#1}\typec\langle\parc{#2}\typec\rangle}
% \newcommand{\CALLNT}[2]{\typec{#1}\typec\langle\typec{#2}\typec\rangle} % nested
% \newcommand{\CALLP}[2]{\termc{#1}\langle\termc{#2}\rangle}
% \newcommand{\CALLTT}[3]{\typec{#1}\typec\langle\parc{#2}\typec,\parc{#3}\typec\rangle} % Two params
% \newcommand{\CALLPT}[3]{\termc{#1}\langle\parc{#2},\parc{#3}\rangle} % Two params
% \newcommand{\REPL}[3]{{#1}*?{#2}.{#3}}

% Predefined processes (to use in rules, etc)
% \newcommand{\ifp}{\IF vPQ}
% \newcommand{\resp}{\NU xyP}
% \newcommand{\sendp}{\SEND xyP}
% \newcommand{\receivep}{\RECEIVE xyP}
% \newcommand{\selp}{\SELECT x\ell P}
% \newcommand{\branchp}{\BRANCH x\ell PL}
% \newcommand{\callp}{\CALL Ax}

% Substitution
\newcommand{\subs}[2]{\blk[{\typec{#1}}\blk/{\typec{#2}}\blk]} % [T/x] -- type substitution
\newcommand{\vsubs}[2]{\blk[\termc{#1}\blk/\termc{#2}\blk]} % [p/x] -- term substitution
\newcommand{\nsubs}[2]{\nsymc{#1}\blk/\nsymc{#2}}

% The variable convention, so that we do not have to write it twice
\newcommand{\varconvention}{the bound variables of processes that occur in a
mathematical context are taken to be different from the free
variables}

%%% JUDGEMENTS

\newcommand{\axiom}[1]{\frac{}{#1}}
% \newcommand{\axiom}[1]{{#1}}

%\newcommand{\judgementlabel}[1]{\operatorname{#1}} % labels in judgements
\newcommand{\judgementlabel}[1]{\mathsf{#1}} % labels in judgements
\newcommand{\sessionlabel}[1]{\judgementlabel{{#1}_s}}
\newcommand{\eqlabel}[1]{\judgementlabel{{#1}^e}} % Equational
\newcommand{\sessioneqlabel}[1]{\judgementlabel{{#1}_s^e}} % Session Equational
\newcommand{\finlabel}[1]{\judgementlabel{{#1}_\sysf}} % Recursive
\newcommand{\reclabel}[1]{\judgementlabel{{#1}_\sysr}} % Recursive
\newcommand{\onelabel}[1]{\judgementlabel{{#1}_\sysone}} % 1-counter
\newcommand{\pushtlabel}[1]{\judgementlabel{{#1}_\sysp}} % 1-counter
\newcommand{\twolabel}[1]{\judgementlabel{{#1}_\systwo}} % 2-counter
\newcommand{\inflabel}[1]{\judgementlabel{{#1}_\sysinfty}} % Infinite
\newcommand{\conlabel}[1]{\judgementlabel{{#1}_\syscf}} % Context-free
\newcommand{\neslabel}[1]{\judgementlabel{{#1}_\sysn}} % Nested

% Basic judgement. E.g., T type,  P proc
\newcommand{\judgement}[2]{{#1} \: \judgementlabel{#2}}

% Judgement with a context. E.g., Z |- T type_e
\newcommand{\judgementctx}[3]{{#1} \vdash \judgement{#2}{#3}}

% Judgement with two contexts. E.g., A | X |- P proc_e
\newcommand{\judgementbictx}[4]{{#1} \mid {#2 }\vdash \judgement{#3}{#4}}

% Judgement for a binary relation. E.g., T <: T,  S \bot S
\newcommand{\judgementrel}[3]{{#1} \; {#2} \; {#3}}

% Judgement for a binary relation that behaves as a function. E.g., Γ + Γ = Γ,  P[v/x] = P
\newcommand{\judgementfun}[2]{\judgementrel{#1}{\mapsto}{#2}}

% Judgement for a binary relation w/ context. E.g.,  Γ |- v : T
\newcommand{\judgementrelctx}[4]{{#1} \vdash \judgementrel{#2}{#3}{#4}}

% Judgement for a binary relation w/ context and a label. E.g.,  Γ |- v : T
\newcommand{\judgementrelctxlab}[4]{{#1} \vdash \judgementrel{#2}{#3}{#4}}

\newcommand{\judgementrelbictxlab}[5]{{#1} \mid {#2} \vdash \judgementrel{#3}{#4}{#5}}

% Syntax Formation
% Types
% \newcommand{\isType}[2]{\judgement{\typec{#1}}{#2}} % In general

\newcommand{\istype}[3]{\judgementrelctxlab{#1}{\typec{#2}}{:}{\kindc{#3}}}
\newcommand{\istypef}[1]{\isType{#1}{\finlabel{type}}} % Finite
\newcommand{\istyper}[1]{\isType{#1}{\reclabel{type}}} % Recursive
\newcommand{\istypeo}[1]{\isType{#1}{\onelabel{type}}} % 1-counter
\newcommand{\istyped}[1]{\isType{#1}{\pushtlabel{type}}} % Pushdown
\newcommand{\istypet}[1]{\isType{#1}{\twolabel{type}}} % 2-counter
\newcommand{\istypei}[1]{\isType{#1}{\inflabel{type}}} % Infinite
\newcommand{\istypec}[1]{\isType{#1}{\conlabel{type}}} % Context-free
\newcommand{\istypen}[1]{\isType{#1}{\neslabel{type}}} % Nested
\newcommand{\prekind}[3]{{#1} \vdash_{\keyword{pre}}\judgementrel{\typec{#2}}{:}{\kindc{#3}}}
 % Pre-kinding

% Values and processes
% \newcommand{\isvalf}[2]{\judgementctx{#1}{#2}{val}}
\newcommand{\isprocf}[2]{\judgementctx{#1}{#2}{proc}}
\newcommand{\isprocef}[4]{\judgementrelbictxlab{#1}{#2}{\termc{#3}}{:}{\typec{#4}}}  % Equational
% Contexts
\newcommand{\isstype}[2][n]{\isType{#2}{stype}_{#1}} % Session
% \newcommand{\isctx}[1]{\judgement{#1}{ctx}}
% \newcommand{\iseqctx}[1]{\judgement{#1}{\judgementlabel{tctx}}}
% Terms
\newcommand{\isnat}[1]{\judgement{\parc{#1}}{nat}}
\newcommand{\isstr}[1]{\judgement{\parc{#1}}{str}}
\newcommand{\isdone}[1]{\judgement{\typec{#1}}{\!\checkmark}}
\newcommand{\isnotdone}[1]{\judgement{\typec{#1}}{\not\!\checkmark}}

% Term (expression) typing
\newcommand{\isterm}[4]{{#1}\mid{#2}\vdash\termc{#3}\colon\typec{#4}}
\newcommand{\termsynth}[5]{{#1}\mid{#2}\vdash\termc{#3}\Rightarrow\typec{#4}\mid{#5}}
\newcommand{\termagainst}[5]{{#1}\mid{#2}\vdash\termc{#3}\Leftarrow\typec{#4}\mid{#5}}

% Process typing
\newcommand{\isproc}[2]{{#1}\vdash{\termc{#2}}}

% Duality
\newcommand{\isDual}[3]{\judgementrel{\typec{#1}}{#2}{\typec{#3}}}
\newcommand{\isdual}[2]{\isDual{#1}{\bot}{#2}}
\newcommand{\isdualr}[2]{\isDual{#1}{\reclabel{\bot}}{#2}}
\newcommand{\isdualo}[2]{\isDual{#1}{\onelabel{\bot}}{#2}}
\newcommand{\isduald}[2]{\isDual{#1}{\pushtlabel{\bot}}{#2}}
\newcommand{\isdualt}[2]{\isDual{#1}{\twolabel{\bot}}{#2}}
\newcommand{\isduali}[2]{\isDual{#1}{\inflabel{\bot}}{#2}}
% \newcommand{\isduale}[3]{\judgementrelctx{#1}{#2}{\judgementlabel{\bot}}{#3}} % Equational
% \newcommand{\isdualc}[2]{\judgementrel{#1}{\oplab{\bot}{c}}{#2}} % Coinductive
% session types
% \newcommand{\issdual}[2]{\isdual{#1}{#2}}
% \newcommand{\issduale}[3]{\judgementrelctx{#1}{#2}{\sessioneqlabel{\bot}}{#3}}

% Subtyping
\newcommand{\issubt}[2]{\judgementrel{#1}{\sub}{#2}}
\newcommand{\issubte}[3]{\judgementrelctx{#1}{#2}{\eqlabel{\sub}}{#3}} % Equational
% \newcommand{\issubtc}[2]{\judgementrel{#1}{\oplab{\sub}{c}}{#2}} % Coinductive
% session types
% \newcommand{\isssubt}[2]{\issubt{#1}{#2}}
% \newcommand{\isssubte}[3]{\judgementrelctx{#1}{#2}{\sessioneqlabel{\sub}}{#3}}

% Compatibility
% \newcommand{\iscompat}[2]{\judgementrel{#1}{\compat}{#2}}
% \newcommand{\iscompate}[3]{\judgementrel{#1}{\eqlabel{\compat}}{#2}} % Equational
% \newcommand{\iscompatc}[2]{\judgementrel{#1}{\oplab{\compat}{c}}{#2}} % Coinductive

% Equivalence
\newcommand{\isEquiv}[3]{\judgementrel{\typec{#1}}{#2}{\typec{#3}}}
\DeclareDocumentCommand{\isequiv} { m m } { \isEquiv{#1}{\teq}{#2} }
\newcommand{\isequivnokind}[2]{\isEquiv{#1}{\teq}{#2}}
\newcommand{\isnotequiv}[2]{\isEquiv{#1}{\not\teq}{#2}}
\newcommand{\isequivf}[2]{\isEquiv{#1}{\finlabel{\teq}}{#2}}
\newcommand{\isequivr}[2]{\isEquiv{#1}{\reclabel{\teq}}{#2}}
\newcommand{\isequivo}[2]{\isEquiv{#1}{\onelabel{\teq}}{#2}}
\newcommand{\isequivd}[2]{\isEquiv{#1}{\pushtlabel{\teq}}{#2}}
\newcommand{\isequivt}[2]{\isEquiv{#1}{\twolabel{\teq}}{#2}}
\newcommand{\isequivi}[2]{\isEquiv{#1}{\inflabel{\teq}}{#2}}
\newcommand{\issequiv}[2]{\isequiv{#1}{#2}}

%Pairs
\DeclareDocumentCommand{\ispair} { m m } { (\typec{#1},\typec{#2})}

% Bisimilarity
% \newcommand{\isbisim}[2]{\typec{#1} \sim \typec{#2}}
\DeclareDocumentCommand{\isbisim} { m m } { \isEquiv{#1}\sim{#2} }
\DeclareDocumentCommand{\isbisimg} { m m } { \judgementrel{\nsymc{#1}}{\gequiv}{\nsymc{#2}} }

% Normalisation
\newcommand{\isnorm}[2]{\judgementrel{\typec{#1}}{\Downarrow}{\typec{#2}}}

% Embedding
\newcommand{\embeds}[2]{\judgementrel{\typec{#1}}{\hookrightarrow}{\typec{#2}}}

% Error
\newcommand{\iserr}[1]{\judgement{#1}{error}}
\newcommand{\iserre}[1]{\judgement{#1}{\eqlabel{error}}} % Equational
% \newcommand{\iserrc}[1]{\judgement{#1}{error_c}} % Coinductive

% Equations
\newcommand{\iseqt}[2]{\judgementrel{\typec{#1}}{\Eq}{\typec{#2}}} % type equation
\newcommand{\iseqp}[2]{\judgementrel{\termc{#1}}{\Eq}{\termc{#2}}} % process equation
\newcommand{\iseq}[2]{\judgementrel{#1}{\Eq}{#2}} % type equation
\newcommand{\lhs}[2]{#1\langle{\parc{#2}}\rangle}
\newcommand{\lhst}[2]{\typec{#1}\typec\langle{\parc{#2}}\typec\rangle}
\newcommand{\lhsp}[2]{#1\termclangle{\parc{#2}}\termc\rangle}
% \newcommand{\lhst}[2]{\lhst{\typec{#1}}{#2}}
\newcommand{\lhstt}[3]{\lhst{\typec{#1}}{{#2}\typec{,}{#3}}} % two params
\newcommand{\ispeqt}[3]{\iseqt{\lhs{#1}{#2}}{#3}} % is parameter type
\newcommand{\ispeqp}[3]{\iseqp{\lhs{#1}{\termc{#2}}}{\termc{#3}}} % is parameter process

% Context entry
\newcommand{\entry}[2]{\typec{#1}\colon\kindc{#2}}

% Context addition
\newcommand{\ctxadd}[3]{\judgementfun{{#1}\cadd{#2}}{#3}}

% Dualof
\newcommand{\dualof}[2]{\judgementfun{\dual #1}{#2}}

% Structural congruence and reduction
\newcommand{\isscong}[2]{\judgementrel{\termc{#1}}{\equiv}{\termc{#2}}}
\newcommand{\osred}{\,\rightarrow\,}
\newcommand{\osrede}{\,\eqlabel{\rightarrow}\,} % Equational
%\newcommand{\osredc}{\,\oplab{\rightarrow}{c}\,} % Coinductive
\newcommand{\isred}[2]{\judgementrel{\termc{#1}}{\rightarrow}{\termc{#2}}}
\newcommand{\ltsarrow}[1]{\stackrel{#1}{\longrightarrow}}
%\newcommand{\betaarrow}{\longrightarrow}
\newcommand{\betaarrow}{\rightarrow} % So that we may use \nrightarrow to negate
\newcommand{\muarrow}{\longrightarrow_\mu}
\newcommand{\lseqarrow}{\longrightarrow_{\beta;D}}
\newcommand{\gltsred}[3]{\nsymc{#1}\ltsarrow{\tsymc{#2}}\nsymc{#3}}
\newcommand{\ltsred}[3]{\typec{#1}\ltsarrow{\tsymc{#2}}\typec{#3}}

% Reduction
\newcommand{\betared}[2]{\typec{#1}\betaarrow\typec{#2}} % types
\newcommand{\betareds}[2]{\typec{#1}\betaarrow^*\typec{#2}} % types
\newcommand{\mured}[2]{\typec{#1}\muarrow\typec{#2}} % types
\newcommand{\lseqred}[2]{\typec{#1}\lseqarrow\typec{#2}} % types
\newcommand{\lambdared}[2]{\typec{#1}\betaarrow\typec{#2}} % types
\newcommand{\normalred}[2]{\typec{#1}\Downarrow\typec{#2}} % types
\newcommand{\munormalred}[2]{\typec{#1}\Downarrow_\mu\typec{#2}} % types
\newcommand{\lseqnormalred}[2]{\typec{#1}\Downarrow_{\beta;D}\typec{#2}} % types
\newcommand{\expred}[2]{\termc{#1}\rightarrow\termc{#2}} % expressions
\newcommand{\procred}[2]{\expred{#1}{#2}} % processes

% Weak head normal form
\newcommand{\iswhnf}[1]{\judgement{\typec{#1}}{whnf}} % types
\newcommand{\issnf}[1]{\judgement{\typec{#1}}{nf}} % types

% Normalisation (beta-reduction)
\newcommand{\isnormalised}[1]{\judgement{\typec{#1}}{norm}} % types
%\newcommand{\isnormalised}[1]{\judgement{\typec{#1}}{norm}} % types
% Contractiveness
% with normalisation, this macro should be removed --am
% contr is now norm
%\newcommand{\iscontrt}[1]{\judgement{\typec{#1}}{contr}} % types
\newcommand{\iscontrt}[1]{\isnormalised{#1}} % types
\newcommand{\iscontrp}[1]{\judgement{\termc{#1}}{contr}}  % processes
\newcommand{\iscontrf}[1]{\judgement{#1}{\finlabel{contr}}} % Recursive
\newcommand{\iscontrr}[1]{\judgement{#1}{\reclabel{contr}}} % Recursive
\newcommand{\iscontro}[1]{\judgement{#1}{\onelabel{contr}}} % 1-counter
\newcommand{\iscontrd}[1]{\judgement{#1}{\pushtlabel{contr}}} % Pushdown
% \newcommand{\iscontrt}[1]{\judgement{#1}{\twolabel{contr}}} % 2-counter
\newcommand{\iscontri}[1]{\judgement{#1}{\inflabel{contr}}} % 2-counter
\newcommand{\unfoldrel}[2]{\unfold(\typec{#1})=\typec{#2}}
% Un and Lin
\newcommand{\isun}[1]{\judgement{#1}{un}}
\newcommand{\islin}[1]{\judgement{#1}{lin}}

% Free Vars
\newcommand{\isfv}[2]{\judgementrel{\fv({#1})}{=}{#2}} % Deprecated:
%use process formation
\newcommand{\isfvsub}[2]{\vdash\fv({#1})\subseteq{#2}} % ???

% Expressions and Processes
\newcommand{\isvalue}[1]{\judgement{\termc{#1}}{value}}
\newcommand{\isprocdone}[1]{\judgement{\termc{#1}}{terminated}}
\newcommand{\isredex}[1]{\judgement{\termc{#1}}{redex}}
\newcommand{\isruntimeerr}[1]{\judgement{\termc{#1}}{runtime error}}


% Substitution
\newcommand{\issubs}[4]{\judgementfun{{#1}\subs{#2}{#3}}{#4}}
\newcommand{\issubsb}[4]{\issubs{#1}{#2}{#3}{#4}}
\newcommand{\substitute}[3]{\typec{#1\blk{[\typec{#2} \mapsto \typec{#3}]}}}
% \newcommand{\issubsb}[4]{\judgementrel {{#1}\subs{#2}{#3}} {=}{#4}}
  % basic system, with an =, should be indistinguishable from
  % the coinductive version % Why do we need two different?

% The type ids in an equational context
\newcommand{\tids}[2]{\judgementfun{\ids({#1})}{#2}}

% TRANSLATION _ WE DECIDED TO RELY ON THE INTUITION THAT EQUATIONAL
% TYPES CAN BE FAITHFUL TRANSLATED TO COINDUCTIVE TYPES.

% \newcommand{\transt}[1]{\llbracket{#1}\rrbracket} % Types
% \newcommand{\transs}[1]{\llparenthesis{#1}\rrparenthesis} % Sessions
% \newcommand{\transp}[1]{\transt{#1}} % Processes
% \newcommand{\istranst}[3]{\judgementrelctx {#1}{\transt{#2}}{\yields}{#3}} % Types
% %\newcommand{\istranss}[3]{\istranst{#1}{#2}{#3}} % Sessions
% \newcommand{\istranss}[3]{\judgementrelctx{#1}{\transs{#2}}{\yields}{#3}} % Sessions
% \newcommand{\istransp}[4]{\istranst{#1\mid#2}{#3}{#4}} % Processes
% \newcommand{\istransc}[2]{\istranst\empty{#1}{#2}} % Contexts
% \newcommand{\istranssr}[3]{\istranss\empty{#1}{#2;#3}} % Recursive sessions
% \newcommand{\istranstr}[3]{\istranst\empty{#1}{#2;#3}} % Recursive types

% Algorithmic type checking
% \newcommand{\valsynth}[4]{{#1}\vdash{#2}\Rightarrow{#3};{#4}}
% \newcommand{\valcheck}[4]{{#1}\vdash{#2}:{#3}\Rightarrow{#4}}
% \newcommand{\procsynth}[5]{{#1};{#2}\vdash{#3}\Rightarrow{#4};{#5}}
% \newcommand{\isalgsubt}[3]{{#1}\vdash{#2}\sub{#3}}

% Side condition in algorithmic type checking
\newcommand{\sidecondition}[1][q]{\text{if }{#1}=\lin\text{ then } \{x\} \text{ else }\emptyset}

% Grammars
\newcommand{\prodsymbol}{\rightarrow}
\newcommand{\tracesymbol}{\Rightarrow}
\newcommand{\gprod}[2]{\nsymc{#1} \prodsymbol #2}
\newcommand{\grel}[2]{#1 \prodsymbol #2}
\newcommand{\grels}[2]{#1 \prodsymbol^\ast #2}
\newcommand{\sdgrels}[3]{\nsymc{#1} \overset{\tsymc{#2}}{\tracesymbol} \nsymc{#3}}
\newcommand{\istrace}[2]{\nsymc{#1} \overset{\tsymc{#2}}{\tracesymbol}}
% Notes

% The predefined color< names are black, blue, brown, cyan, darkgray,
% gray, green, lightgray, lime, magenta, olive, orange, pink, purple,
% red, teal, violet, white, yellow.
% \newcommand{\note}[1]{\textbf{\textcolor{teal}{[Note:}} {#1}\textcolor{teal}]}
\newcommand{\todo}[1]{\textbf{\textcolor{teal}{[TODO:}} {#1}\textcolor{teal}]}
\newcommand{\sg}[1]{\marginpar{\textcolor{red}{#1}}}
\ifx\vv\undefined
\newcommand{\vv}[1]{\marginpar{\textcolor{blue}{#1}}}
\else
\renewcommand{\vv}[1]{\marginpar{\textcolor{blue}{#1}}}
\fi

\newcommand{\myparagraph}[1]{\vspace{-1em}\paragraph{#1}}
% \newcommand{\myparagraph}[1]{\smallskip\noindent\textbf{#1~}}

% Writing, according to the Handbook for Scholars
\newcommand{\ie}{i.e.,\xspace} % comma
\newcommand{\eg}{e.g.\xspace}  % no comma
\newcommand{\st}{s.t.\xspace}  % no comma
\newcommand{\etal}{et al.\xspace} % al abbreviates aliae, no need for am \emph,
                                % but you may added if you feel like
\newcommand{\cf}{cf.~} % Latin confer


%Updates of De Bruijn indexes:
\newcommand{\updt}[3]{\uparrow^{#1}_{#2}\! ({#3})}

% Listings


\lstdefinestyle{eclipse}{
  breaklines=true,
  basicstyle=\sffamily\Small,
  emphstyle=\color{RoyalBlue}\bfseries,
  keywordstyle=\color{RedViolet}\bfseries,
  % commentstyle=\color{darkgreen},
  % stringstyle=\color{darkblue},
  % numberstyle=\color{darkgrey},%\lstfontfamily,
  showstringspaces=false,
}

\lstset{
  language=Haskell,
  basicstyle=\ttfamily\small,
  keywordstyle=\color{RedViolet}\ttfamily,
  commentstyle=\color{blue!50}\ttfamily,
  emphstyle=\color{RoyalBlue}\ttfamily, % types
  morekeywords=[1]{type, rec, let, in, if, then,
    else, new, send, receive, select, close, fork, case, of, data, match, with, True,
    False},
  deletekeywords={Int,Bool},
  emph={Skip,End,Close,Wait,Unit,Dual,Int,Bool},
  literate=
  {|>}{$\triangleright$}2
  {->}{$\rightarrow$}2
  {=>}{$\Rightarrow$}2 
  {forall}{$\forall$}1
  {Lambda}{$\Lambda$}1
  {lambda}{$\lambda$}1
  {mu}{$\mu$}1
  {alpha}{$\alpha$}1
  {oplus}{$\oplus$}1
  {+\{}{$\oplus$\{}2
  ,
  breaklines=true,
  tabsize=2
}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "42-CR"
%%% End:
