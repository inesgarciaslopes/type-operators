\section{Deciding Type Equivalence}\label{sec:deciding-type-equivalence}
Following Po√ßas et al. \cite{PocasCMV23}, the problem of checking whether two (renamed) types are equivalent is reduced to translating types into grammars and checking bisimilarity there. A grammar in \emph{Greibach normal form} \cite{AutebertG84} is a tuple $(\mathcal{T, N}, \ntgamma, \mathcal{R})$, where:
\begin{itemize}
	\item $\mathcal{T}$ is a finite set of terminal symbols, $\tsymc{a}$, $\tsymc{b}$, $\tsymc{c}$; 
	\item $\mathcal{N}$ is a finite set of non-terminal symbols, $\Xnt, \Ynt, \Znt$;
	\item $\ntgamma\in\mathcal{N}^*$ is the starting word;
	\item $\mathcal{R} \subseteq \N \times \T \times \N^*$ is a finite set of production rules.
\end{itemize}

\input{word}
A production rule in $\mathcal{R}$ is written as $\ltsred{\Xnt}{a}{\ntdelta}$. Grammars in GNF are \emph{simple} when, for every non-terminal symbol $\Xnt$ and every terminal symbol $\tsymc{a}$, there is at most one production rule $\ltsred{\Xnt}{a}{\ntdelta}$ \cite{KorenjakH66}.

The function $\word({\typec{T}})$, described in \cref{fig:word}, translates types to words of non-terminal symbols. If a type $\TT$ is in weak head normal form, the construction of $\word(\TT)$ creates a fresh non-terminal, $\Ynt$, and updates the set of productions of $\TT$, according to one of the cases found in $\word'$. Actually, a fresh non-terminal is created only if the type currently in scope is syntactically different from all previously visited types. If $\TT$ is not in weak head normal form and normalises to $\Skip$, we return the empty word; otherwise, if there exists a type $\UT\neq \Skip$ such that $\TT$ normalises to $\UT$, consider $\word(\UT) = \Znt \ntdelta$ and $\Ynt$ a fresh new terminal. For each production of $\Znt$ of the form $\gltsred Z a {\gamma}$, then $\Ynt$ has a production of the form $\gltsred Y a {\gamma\delta}$. 
The application of the $\word$ function to a type $\TT$ terminates producing a simple grammar. This is only possible because our well-formed types normalise, and all of its subtypes normalise as well. Furthermore, since we keep track of already visited types, we are able to reuse non-terminal symbols, which is crucial for dealing with recursive types.

We check if two types are equivalent by means of translating the (renamed) types to a simple grammar, and then checking if their bisimilarity, \ie if $\word({\typec{T}}) \gequiv \word({\typec{U}})$. The algorithm used to check bisimilarity of simple grammars is the one introduced by Almeida et al. \cite{AlmeidaMV20}.

\todo{grammar example: T$\sim$U}
