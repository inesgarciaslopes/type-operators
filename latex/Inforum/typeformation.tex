\section{Deciding Type Formation}\label{sec:deciding-type-formation}
The rules for type formation in \cref{fig:type-formation} involve determining if an application type $\TT\UT$ normalises.
Types that reduce infinitely many times must be excluded. However, determining whether $\isnormalised {\TT\UT}$ may not terminate. Po\c{c}as et al. \cite{PocasCMV23} propose a two-step solution to this problem.
The first stage is the introduction of the concept of \emph{pre-kinding}. We denote this as $\prekind \Delta T \kind$, that is, $\typec{T}$ is pre-kinded with kind $\kind$ under the kinding context $\Delta$, a map from type variables to kinds. The rules for pre-kinding can be found in \cref{fig:pre-kinding}. They differ from the rules for type formation in that in rule \pktapp there is no verification of the normalisation of $\TT\UT$. Pre-kinding excludes some (but not all) types that do not normalise, as is the case of $\typec{(\tlambda{\alpha}{\kind}{\alpha \alpha})(\tlambda{\alpha}{\kind}{\alpha \alpha})}$, in \cref{fig:ex-pre-kinding}.

\input{pre-kinding}

\begin{figure}[t]
	\begin{equation*}
		\inferrule*[rightstyle = {\scriptsize \sc}, right = PK-TApp]{
			\inferrule*[rightstyle = {\scriptsize \sc}, right = PK-TAbs]{
				\inferrule*[rightstyle = {\scriptsize \sc}, right = PK-TApp, rightskip=9em]{
					\infer[\textsc{\scriptsize PK-Var}]{
						\kind = \karrow {\kind''} {\kind'}
					}{
						\prekind {\typec{\alpha}:\kind} {\alpha} {\karrow {\kind''} {\kind'}}
					}
					\quad
					\infer[\textsc{\scriptsize PK-Var}]{
						\bot}{
						\prekind {\typec{\alpha}:\kind} {\alpha} {\kind''}
					}
				}{
					\prekind {\typec{\alpha}:\kind} {\alpha \alpha} {\kind'}
				}
			}
			{
				\prekind {} {\tlambda{\alpha}{\kind}{\alpha \alpha}} {\karrow {\kind} {\kind'}}
			}
			\qquad
			\inferrule*[]{
				\vdots}{
				\prekind {} {\tlambda{\alpha}{\kind}{\alpha \alpha}} {\kind}
			}
		}
		{
			\prekind {} {(\tlambda{\alpha}{\kind}{\alpha \alpha})(\tlambda{\alpha}{\kind}{\alpha \alpha})} {\kind'}
		}
	\end{equation*}
	\caption{Example of an unsuccessful derivation of kind for $\typec{(\tlambda{\alpha}{\kind}{\alpha \alpha})(\tlambda{\alpha}{\kind}{\alpha \alpha})}$.}
	\label{fig:ex-pre-kinding}
\end{figure}

For a type which is pre-kinded, termination of $\isnormalised {\TT}$ is guaranteed. Note that some recursive types are problematic for normalisation, as the reduction of some types might not decrease their size. For example, the type $\tmu\skind\ (\tabs\alpha\skind {\alpha;\Skip})$ is pre-kinded but successive reduction steps keep adding $\typec{;}\Skip$ to the tail of the type so we must conclude that it does not normalise.
When dealing with normalisation, we separate the way we treat recursive types from the rest.
In particular, we divide the reduction rules into two groups: $\muarrow$ refers to reductions that use the $\rmu$ rule and $\lseqarrow$ refers to reductions that never invoke the $\rmu$ rule. Thus, $\betaarrow\ =\ \lseqarrow\cup\muarrow$. We can now extend this notion into normalisation $\lseqnormalred TU$ and $\munormalred TU$ respectively.

In order to check if a type $\TT$ is well-formed, we first synthetise the kind of $\TT$, \ie we determine if $\prekind\Delta T \kind$ for some $\Delta, \kind$. If $\TT$ fails to be pre-kinded, it is not kinded either.


\todo{rewrite from here.}
Otherwise, we check whether $\TT$ normalises, specifically seeking infinite reduction sequences. In the presence of recursive types, such sequences would have between two $\mu$-reductions a finite number of $\beta$-reductions.
$\TT = \lseqnormalred{\typec{T_0}}{\typec{T'_0}}\mured{}{\typec{T_1}}\lseqnormalred{}{\typec{T'_1}}\mured{}{\typec{T_2}}\lseqnormalred{}{\typec{T'_2}}\mured{}{\cdots}$.
If $\typec{T'_i}$ does not reduce by any $\mu$-reduction, we can determine that $\typec{T}$ normalises. Otherwise, since $\tmu\kast\ \UT$ is restricted to the base kind $\kast$, it must reduce by one of these:
\begin{equation*}\begin{aligned}
\typec{T'_i} &= \mured{\tapp{\tmu\kast}\UT}{\tapp\UT{(\tapp{\tmu\kast}\UT)}} & (\rmu)
\\
\typec{T'_i} &= \mured{\semit{(\tapp{\tmu\kast}\UT)}{V}}{\semit{(\tapp U{(\tapp{\tmu\kast}\UT)})}{V}} & (\rseqtwo)
\\
\typec{T'_i} &= \mured{\tdual{(\tapp{\tmu\kast}\UT)}}{\tdual{(\tapp U {(\tapp{\tmu\kast}\UT)})}} & (\rdctx)
\\
\typec{T'_i} &= \mured{\semit{(\tdual{(\tapp{\tmu\kast}\UT)})}{V}}{\semit{(\tdual{(\tapp U {(\tapp{\tmu\kast}\UT)})})}{V}} & (\rseqtwo + \rdctx)
\end{aligned}\end{equation*}
We can easily notice that the expression $\tmu\kast\ \UT$ reappears after the $\mu$-reduction, indicating potential infinite sequences. We can detect these by tracking occurrences of $\tmu\kast\ \UT$ and halting if a repetition is found.
The following pseudo-code illustrates the process for determining if $\typec{T}$ normalises: 

\begin{lstlisting}
    normalises(visited, t) = 
        if reducesByBSD(t) then
            normalises(visited, t') -- t -> t'
        else if memberOf(t, visited) then
            Nothing -- found an infinite sequence
        else if reducesByMu(t) then
            normalises(visited', t') -- update visited set with t
        else t
\end{lstlisting}