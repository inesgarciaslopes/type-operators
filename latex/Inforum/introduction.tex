\section{Introduction}\label{sec:intro}
In the field of programming languages, the drive for more advanced and expressive type systems never stops. This journey has led us from the foundational System $F$\cite{DBLP:conf/programm/Reynolds74} to the more intricate System $F^{\mu}_\omega$\cite{DBLP:conf/popl/CaiGO16}. Integrating these advanced systems into real-world programming languages, however, comes with its own set of challenges, especially when it comes to type equivalence.

FreeST \cite{AlmeidaMTV22}, a concurrent functional programming language based on system $F^{\mu;}$, is regulated by context-free session types. Context-free session types, unlike regular session types, are not restricted to tail recursion, thus allowing the description of more sophisticated communication protocols. FreeST's current type equivalence algorithm, developed by Almeida et al. \cite{AlmeidaMV20} decides the equivalence of context-free session types by reducing the problem to the bisimilarity of simple grammars. The next step is to extend the language to a higher-order setting where type equivalence is still decidable.


In this work, we study the System $F^{\mu_*;}_\omega$, the higher-order polymorphic lambda calculus equipped with equirecursive and context-free session types and its incorporation into a programming language. We follow a bisimulation-based type equivalence, proposed by Po√ßas et al.~\cite{DBLP:conf/esop/PocasCMV23}, which supports the robust implementation of advanced type systems in programming languages. We seek to bridge the gap between advanced type theory and practical compiler design, ensuring that the powerful capabilities of context-free session types can be effectively utilized without compromising on performance or reliability.

In the development of modern type systems, combining advanced features such as equirecursion, higher-order polymorphism, and higher-order context-free session types presents unique challenges and opportunities. The primary motivation for our research is to integrate these elements into a cohesive type system that can be practically incorporated into programming languages. Therefore, we are interested in practical algorithms for type equivalence checking to be incorporated into compilers.

\paragraph{Context-free session types and beyond.}
Context-free session types break free from tail recursion by introducing the sequential composition operator $\Semi$ and the type $\Skip$---neutral element of sequential composition---which represents a protocol with no actions.
The recursive type $\tmuinfix{\alpha}{\skind}{\extchoice\rchannel{\leafl}{\Skip}{\nodel}{\alpha\Semi\ \INp\Int\Semi\ \alpha}}\Semi\End_{\typec{?}}$ describes a protocol for safely streaming integer trees on a channel. The channel presents an external choice $\extchoice$ with two labels: if the continuation of the channel is $\leafl$, then no communication occurs but the channel is still open for further composition whereas, if the continuation of the channel is $\nodel$, then we have a left subtree, followed by an integer and a right subtree. When the whole tree is received, the channel is closed. It is also important to distinguish type $\End_{\typec{?}}$ from $\Skip$---the former represents the closure of a channel, where no further communication is possible, while the latter allows continuing the communication. 
We want to move beyond context-free session types, namely, we are interested in abstracting the type that is received on the tree channel, by writing $\tabs{\beta}{\tkind}{\tmuinfix{\alpha}{\skind}{\extchoice\rchannel{\leafl}{\Skip}{\nodel}{\alpha\Semi\ \INp\beta\Semi\ \alpha}}\Semi\Wait}$. Abstractions introduce higher-order kinds which lead to the introduction of type operators into our language.

\paragraph{Duality as an external macro (or not).}
Duality is the relationship between two session types that allows them to correctly engage in a protocol. For any session type describing one side of the communication (let us say the client), there is a dual session type that describes the other side (the server). For example, the session type $\OUTn\Int$ describes sending an integer and its dual session type is to receive an integer, $\INn\Int$. Typically, duality is offered as a built in constructor \cite{DBLP:journals/corr/abs-2004-01322}. However, we believe duality should be internal, by means of a type operator, since in a polymorphic setting duality cannot be eliminated without the introduction of co-variables.

\paragraph{Outline.}
The rest of the paper is organised as follows: \cref*{sec:system} introduces System $F^{\mu_*;}_\omega$ and type equivalence; \cref*{sec:deciding-type-formation} presents the challenges encountered during this research and prove the decidability of type formation; \cref*{sec:deciding-type-equivalence} explains the decidability of type equivalence; \cref*{sec:implementation} describes our implementation process and validates our work and \cref*{sec:conclusion} wraps up the paper.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "42-CR"
%%% End:
